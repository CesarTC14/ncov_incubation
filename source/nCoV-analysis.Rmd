---
title: "The estimation of the Wuhan coronavirus incubation time"
output: html_document
---

```{r opts, include=FALSE}
knitr::opts_knit$set(root.dir = here::here())
knitr::opts_chunk$set(echo=F, message=T, warning=T, eval=T,
                      fig.align='center',fig.pos='ht')
```

Analysis based on similar procedures for determining the incubation period of Zika virus (Lessler *et al*, 2016.

```{r load, include=FALSE}
library(tidyverse)
library(lubridate)
library(coarseDataTools)
library(gridExtra)

set.seed(1)

## read in coronavirus data
ncov_raw <- read_csv("data/nCoV-IDD-traveler-data.csv") %>% 
    rename(EL_date=EL, ER_date=ER, SL_date=SL, SR_date=SR)

## change dates to restrict exposure to after December 1
## add times where missing
ncov_ELSR <- ncov_raw %>% 
    # if EL is missing or before 1 Dec 2019, use 1 Dec 2019
    mutate(EL_date=ifelse(is.na(EL_date),"2019-12-01 00:00:00", EL_date) %>% 
               ymd_hms() %>% 
               if_else(. < ymd_hms("2019-12-01 00:00:00"),
                       ymd_hms("2019-12-01 00:00:00"), .),
           # if SR is missing, use PR
           SR_date=ifelse(ymd_hms(SR_date) %>% is.na,
                          PR, SR_date) %>% 
               ymd_hms(),
           # SR_fever is only for cases with confirmed fever dates
           SR_fever=ymd_hms(SR_fever))

ncov <- ncov_ELSR %>% 
    # if ER is missing, use SR; if SL is missing, use EL
    mutate(ER_date=if_else(is.na(ER_date), SR_date, ymd_hms(ER_date)),
           SL_date=if_else(is.na(SL_date), EL_date, ymd_hms(SL_date)),
           SL_fever= if_else(is.na(SL_fever) & !is.na(SR_fever), 
                             SL_date,
                             ymd_hms(SL_fever))) %>% 
    # remove any entries missing EL, ER, SL, or SR
    filter(!is.na(EL_date), !is.na(ER_date), !is.na(SL_date), !is.na(SR_date)) %>% 
    # calculate days since 1 Dec 2019
    mutate(EL=difftime(EL_date, ymd_hms("2019-12-01 00:00:00"), units="days") %>% 
               as.numeric(),
           ER=difftime(ER_date, ymd_hms("2019-12-01 00:00:00"), units="days") %>% 
               as.numeric(),
           SL=difftime(SL_date, ymd_hms("2019-12-01 00:00:00"), units="days") %>% 
               as.numeric(),
           SR=difftime(SR_date, ymd_hms("2019-12-01 00:00:00"), units="days") %>% 
               as.numeric(),
           SL_fever=difftime(SL_fever,
                             ymd_hms("2019-12-01 00:00:00"), units="days") %>% 
               as.numeric(),
           SR_fever=difftime(SR_fever,
                             ymd_hms("2019-12-01 00:00:00"), units="days") %>% 
               as.numeric(),
           E_int=ER-EL,
           S_int=SR-SL,
           S_fever_int=SR_fever-SL_fever) %>% 
    # remove entries with exposure/onset intervals less than 0
    # remove entries where ER greater than SR or EL greater than SL
    # remove entries that haven't been reviewed by two people
    filter(E_int > 0, S_int > 0, ER<=SR, SL>=EL, !is.na(REVIEWER2))

## Now lets divide data sets by observation type
## only fevers
ncov_fever <- ncov %>% 
    filter(!is.na(SL_fever) | !is.na(SR_fever))

## only travel outside of China
ncov_foreign <- ncov %>% 
    filter(COUNTRY.DEST != "China")

## only fevers outside of China
ncov_foreign_fever <- ncov_fever %>% 
    filter(COUNTRY.DEST != "China")
```

```{r data-summary, echo=FALSE, message=FALSE, warning=FALSE, fig.height=7}
dat_sum <- ncov %>%
    mutate(ELnew = EL-ER,
           ERnew = ER-ER,
           SLnew = SL-ER,
           SRnew = SR-ER)

ggplot(dat_sum, aes(y=factor(UID))) + 
    geom_segment(aes(x=ELnew, xend=ERnew, yend=factor(UID)), 
                 color="blue", size=2) +
    geom_segment(aes(x=SLnew, xend=SRnew, yend=factor(UID)), 
                 size=2, color="red", alpha=.5) +
    #ggtitle("Incubation Period data") + 
    scale_x_continuous("") +
    ylab("UID") +
    theme_bw() +
    # coord_cartesian(xlim = c(-40, 50)) +
    theme(axis.text.y = element_text(size=6)) +
    annotate("text", x=-35, y="900.1", label="A")
```

We have data with which to estimate the incubation period from `r nrow(ncov)` people.
The median exposure interval was `r round(median(ncov$E_int),1)` (range: `r round(min(ncov$E_int),1)`-`r round(max(ncov$E_int),1)`).
The median symptom onset interval was `r round(median(ncov$S_int),1)` (range: `r round(min(ncov$S_int),1)`-`r round(max(ncov$S_int),1)`).

# coarseDataTools Bootstrap based analyses

We first estimate each relative distribution using coarseDataTools and bootstrapping. Replicating main analysis, assuming a log-normal distribution for the incubation period, and Weibull for the other relevant distributions. 

## Incubation Period

Basic incubation period analysis assuming a log-normal incubation period and using a bootstrap method for calculating confidence intervals.
We also run the asymptotic intervals, which run much faster.

```{r fit dic, results='hide', cache=T}
#make the data to pass in to dic.fit
# inc.dat <- zika.inc[,c("EL","ER","SL","SR")]
# inc.dat$type <- 0

ncov_inc_dat <- ncov %>% 
    select(EL, ER, SL, SR) %>% 
    mutate(type=0) %>% 
    as.data.frame()

#fit it...use bootstrap interstions for now. MCMC better?
# inc.fit <- dic.fit(inc.dat,dist="L",n.boots=5000,
#                    ptiles = c(0.05, 0.25, 0.5, 0.75, 0.95))

ncov_inc_fit_asym <- dic.fit(ncov_inc_dat,dist="L",#n.boots=5000,
                             ptiles = c(0.05, 0.25, 0.5, 0.75, 0.95))

ncov_inc_fit_boot <- dic.fit(ncov_inc_dat,dist="L", n.boots=5000,
                             ptiles = c(0.05, 0.25, 0.5, 0.75, 0.95))
```

```{r dic-plots}
# plot(inc.fit, xlim=c(0,20), plot.n.samps=2000)
# inc.fit

## plot the boot fit and table of intervals
plot(ncov_inc_fit_boot, main="bootstrap results")
ncov_inc_fit_boot

## plot the asymptotic fit and table of intervals
plot(ncov_inc_fit_asym, main="asymptotic results")
ncov_inc_fit_asym

```

We also made incubation estimates for the fever-only and foreign-only subsets.

```{r fit subset dics, results='hide'}
#make the data to pass in to dic.fit
ncov_fever_dic <- ncov_fever %>% 
    select(EL, ER, SL=SL_fever, SR=SR_fever) %>% 
    mutate(type=0) %>% 
    as.data.frame()

ncov_foreign_dic <- ncov_foreign %>% 
    select(EL, ER, SL, SR) %>% 
    mutate(type=0) %>% 
    as.data.frame()

#fit it...use bootstrap interstions for now. MCMC better?
ncov_fever_fit_asym <- dic.fit(ncov_fever_dic,dist="L",#n.boots=5000,
                               ptiles = c(0.05, 0.25, 0.5, 0.75, 0.95))

# ncov_fever_fit_boot <- dic.fit(ncov_fever_dic,dist="L", n.boots=5000,
#                              ptiles = c(0.05, 0.25, 0.5, 0.75, 0.95))

ncov_foreign_fit_asym <- dic.fit(ncov_foreign_dic,dist="L",#n.boots=5000,
                               ptiles = c(0.05, 0.25, 0.5, 0.75, 0.95))

# ncov_foreign_fit_boot <- dic.fit(ncov_foreign_dic,dist="L", n.boots=5000,
#                              ptiles = c(0.05, 0.25, 0.5, 0.75, 0.95))
```

```{r subset-dic-plots}
## plot the boot fit and table of intervals
# plot(ncov_fever_fit_boot, main="bootstrap results (fever only)")
# ncov_fever_fit_boot

## plot the asymptotic fit and table of intervals
plot(ncov_fever_fit_asym, main="asymptotic results (fever only)")
ncov_fever_fit_asym

## plot the boot fit and table of intervals
# plot(ncov_foreign_fit_boot, main="bootstrap results (foreign only)")
# ncov_foreign_fit_boot

## plot the asymptotic fit and table of intervals
plot(ncov_foreign_fit_asym, main="asymptotic results (foreign only)")
ncov_foreign_fit_asym
```


# Combined stan analysis Lognomal for incubation period, Weibull for others

```{r, eval=FALSE}
require(rstan)


#Create a dataset with everythign lined up for passing into STAN
zika.anal <- zika.inc[,c("UID","EL","ER","SL","SR")]
zika.anal <- merge(zika.anal, vshed.bl.anal, all=TRUE)
zika.anal$type <- 0 #we don't use this, but helps with the merge.
zika.anal <- merge(zika.anal, sero.anal, all=TRUE)

zika.anal$SL[which(is.na(zika.anal$SL))] <- 
  zika.anal$EL[which(is.na(zika.anal$SL))]
zika.anal$SR[which(is.na(zika.anal$SR))] <- 
   zika.anal$ER[which(is.na(zika.anal$SR))] + 100

zika.anal$ACL[which(is.na(zika.anal$ACL))] <-
  zika.anal$EL[which(is.na(zika.anal$ACL))]
zika.anal$ACR[which(is.na(zika.anal$ACR))] <- 
  zika.anal$ER[which(is.na(zika.anal$ACR))] + 720

zika.anal$VCL[which(is.na(zika.anal$VCL))] <-
  zika.anal$EL[which(is.na(zika.anal$VCL))]
zika.anal$VCR[which(is.na(zika.anal$VCR))] <- 
  zika.anal$ER[which(is.na(zika.anal$VCR))] + 720


zika.anal$VCR[which(is.infinite(zika.anal$VCR))] <- 
  zika.anal$ER[which(is.infinite(zika.anal$VCR))] + 720

#renormalize everything so EL is 0
zika.anal[,c("EL","ER","SL","SR","VCL","VCR","ACL","ACR")] <-
  zika.anal[,c("EL","ER","SL","SR","VCL","VCR","ACL","ACR")] -zika.anal$EL  


#for STAN purposes, it is usefule if all of these variables index 
#from 0
stan.data <- list(N=nrow(zika.anal),
                  EL=zika.anal$EL,
                  ER=zika.anal$ER,
                  SL=zika.anal$SL,
                  SR=zika.anal$SR,
                  VL=zika.anal$VCL,
                  VR=zika.anal$VCR, 
                  AL=zika.anal$ACL,
                  AR=zika.anal$ACR)


#initialization version for the lognormal/weibull stan model


#use uniform from halfway trhough the exposure interval to ER.
#still fails occasionally, but MUCH less often. 
stan.init.LWW <- function() {
    rc <-list(E=runif(stan.data$N, (stan.data$EL+stan.data$ER)/2, stan.data$ER),
                lm= runif(1,log(2),log(10)),
                lsd = runif(1,.1,2),
                v_alpha = 2,#,runif(1,5,10),
                v_sigma= 50,# runif(1,.5,2) 
                s_alpha = 2,#,runif(1,5,10),
                s_sigma= 50# runif(1,.5,2) 
                )
    #print(rc) #DEBUG
    #curve(dweibull(x,rc$v_alpha, rc$v_sigma), from=0, to=50) #DEBUG
    return(rc)
    }



#Need at least 35,000 iterations to converge
full.fit.LWW <- stan("DistributionFitLWW.stan", data=stan.data,
                  init=stan.init.LWW,
                  iter=50000, chains=4, thin=10)

save(full.fit.LWW, file = "../FullFitLWW.RData")

```

```{r, eval=FALSE}
load(file = "../FullFitLWW.RData")

#now we need to calculate the quantiles from the chains and construct our
#data frame
chains <- extract(full.fit.LWW)


inc.fit.stan.LWW <- c(median(chains$lm), quantile(chains$lm,prob=c(0.025,0.975)))
inc.fit.stan.LWW <- rbind(inc.fit.stan.LWW,
        c(mean(chains$lsd), quantile(chains$lsd,prob=c(0.025,0.975))))
for (q in c(0.05, 0.25, 0.5, 0.75, 0.95)) {
  tmp <- qlnorm(q, chains$lm, chains$lsd)
  inc.fit.stan.LWW <- rbind(inc.fit.stan.LWW,
                        c(mean(tmp), quantile(tmp, prob=c(0.025, 0.975))))
}

colnames(inc.fit.stan.LWW) <- c("est","CIlow","CIhigh")
rownames(inc.fit.stan.LWW) <- c("meanlog",
                            "sdlog",
                            "p5","p25","p50","p75","p95")



#in stan alpha = shape in R and beta = rate in R
vshed.fit.stan.LWW <- c(median(chains$v_alpha), 
                    quantile(chains$v_alpha,prob=c(0.025,0.975)))
vshed.fit.stan.LWW <- rbind(vshed.fit.stan.LWW,
        c(mean(chains$v_sigma), 
          quantile(chains$v_sigma,prob=c(0.025,0.975))))
for (q in c(0.05, 0.25, 0.5, 0.75, 0.95, 0.99)) {
  tmp <- qweibull(q, chains$v_alpha, chains$v_sigma)
  vshed.fit.stan.LWW <- rbind(vshed.fit.stan.LWW,
                        c(mean(tmp), quantile(tmp, prob=c(0.025, 0.975))))
}

colnames(vshed.fit.stan.LWW) <- c("est","CIlow","CIhigh")
rownames(vshed.fit.stan.LWW) <- c("alpha (shape)",
                            "sigma (scale)",
                            "p5","p25","p50","p75","p95","p99")



#sero
sero.fit.stan.LWW <- c(median(chains$s_alpha), 
                    quantile(chains$s_alpha,prob=c(0.025,0.975)))
sero.fit.stan.LWW <- rbind(sero.fit.stan.LWW,
        c(mean(chains$s_sigma), 
          quantile(chains$s_sigma,prob=c(0.025,0.975))))
for (q in c(0.05, 0.25, 0.5, 0.75, 0.95, 0.99)) {
  tmp <- qweibull(q, chains$s_alpha, chains$s_sigma)
  sero.fit.stan.LWW <- rbind(sero.fit.stan.LWW,
                        c(mean(tmp), quantile(tmp, prob=c(0.025, 0.975))))
}

colnames(sero.fit.stan.LWW) <- c("est","CIlow","CIhigh")
rownames(sero.fit.stan.LWW) <- c("alpha (shape)",
                            "sigma (scale)",
                            "p5","p25","p50","p75","p95","p99")

inc.fit.stan.LWW

vshed.fit.stan.LWW
cat("Mean viral shedding length=",
    vshed.fit.stan.LWW[2,1] * gamma(1+1/vshed.fit.stan.LWW[1,1]),
    "(",vshed.fit.stan.LWW[2,2] * gamma(1+1/vshed.fit.stan.LWW[1,2]),
    ",",vshed.fit.stan.LWW[2,3] * gamma(1+1/vshed.fit.stan.LWW[1,3]),
    ")")
                                  

sero.fit.stan.LWW
cat("Mean time to seroconversion=",
    sero.fit.stan.LWW[2,1] * gamma(1+1/sero.fit.stan.LWW[1,1]),
    "(",sero.fit.stan.LWW[2,2] * gamma(1+1/sero.fit.stan.LWW[1,2]),
    ",",sero.fit.stan.LWW[2,3] * gamma(1+1/sero.fit.stan.LWW[1,3]),
    ")")
              
```



<!-- Based on 4 chains, 50,000 interations per chain, assuming the incubtion period follows a log-normal distribution, and that the time to viral clearance an seroconversion both follow a weibull distributoin, we find that: -->

<!-- The median incubation period is 5.9 days (95% CI: 4.6-7.5) with a dispersion of 1.45 (95% CI: 1.23-1.91). 90% of cases will develop symptoms between 3.2 and 11.2 days of infection (95% CIs: 1.8-4.6 and 7.9-17.8). -->

<!-- The mean time to viral clearanace is estimated to be 9.8 days (95% CI: 7.7-13.4), and  we expext 90% of people to clear virus between 3.5 and 17.9 days after infection (95% CIs: 0.8-5.6 and 12.5-33.9). -->

<!-- The mean time to seroconversion is 9.1 days (95% CI: 7.0-11.1), and we expect 90% of peopld to seroconvert between 4.0 and 14.3 days of infection (95% CIs: 2.1-5.5 and 11.1-19.1). -->


```{r, eval=FALSE}
#Try to use ggplot to plot a beautiful display of the data. 

#first make data frames to hold everything
inc.curve <- NULL
vc.curve <- NULL
sero.curve<- NULL

for (q in seq(0,30,.1)) {
    tmp <- plnorm(q, chains$lm, chains$lsd)
    tmp <- quantile(tmp, prob=c(0.025, .5, 0.975))
    inc.curve <- rbind(inc.curve, c(q=q,
                                    plow=tmp[1],
                                    pmid=tmp[2],
                                    phigh=tmp[3]))
    
    tmp <- 1-pweibull(q, chains$v_alpha, chains$v_sigma)
    tmp <- quantile(tmp, prob=c(0.025, .5, 0.975))
    vc.curve <- rbind(vc.curve, c(q=q,
                                  plow=tmp[1],
                                  pmid=tmp[2],
                                  phigh=tmp[3]))
    
    tmp <- pweibull(q, chains$s_alpha, chains$s_sigma)
    tmp <- quantile(tmp, prob=c(0.025, .5, 0.975))
    sero.curve <- rbind(sero.curve, c(q=q,
                                  plow=tmp[1],
                                  pmid=tmp[2],
                                  phigh=tmp[3]))
}
inc.curve <- as.data.frame(inc.curve)
colnames(inc.curve) <- c("q","incplow","incpmid","incphigh")

vc.curve <- as.data.frame(vc.curve)
colnames(vc.curve) <- c("q","vcplow","vcpmid","vcphigh")

sero.curve <- as.data.frame(sero.curve)
colnames(sero.curve) <- c("q","scplow","scpmid","scphigh")


require(ggplot2)


inc.plt <- ggplot(inc.curve, aes(x=q)) +
  geom_ribbon(aes(ymin=incplow, ymax=incphigh), fill="blue", alpha=.2) +
  geom_line(aes(y=incpmid), col="blue") +theme_bw()+
  scale_x_continuous(limits=c(0, 25), expand = c(0, 0)) + 
  ylab("% w/ symptoms")

vc.plt <- ggplot(vc.curve, aes(x=q)) +
  geom_ribbon(aes(ymin=vcplow, ymax=vcphigh), fill="red", alpha=.2) +
  geom_line(aes(y=vcpmid), col="red") +theme_bw()+
  scale_x_continuous(limits=c(0, 25), expand = c(0, 0)) + 
  ylab("% w/ detectable virus")

sero.plt <- ggplot(sero.curve, aes(x=q)) +
  geom_ribbon(aes(ymin=scplow, ymax=scphigh), fill="darkgreen", alpha=.2) +
  geom_line(aes(y=scpmid), col="darkgreen")+theme_bw()+
  scale_x_continuous(limits=c(0, 25), expand = c(0, 0)) + 
   ylab("% w/ sero-positive")


require(gridExtra)
grid.arrange(inc.plt, vc.plt, sero.plt, ncol=1)

```




<!-- Calculate the means, which translates into risk. -->

```{r, eval=FALSE}

#caclculate the virologic and symptom means and compare.
mns <- data.frame(inc = exp(chains$lm + chains$lsd^2/2),
                  viro = chains$v_sigma*gamma(1+1/chains$v_alpha))

symptom.relative.inc <- quantile((0.8*mns$viro + 0.2*mns$inc)/mns$viro, 
                              prob=c(0.025, .5, 0.975))


to.integrate <- function(t, v_alpha, v_sigma, s_alpha, s_sigma) {
   rc <- (1-pweibull(t,v_alpha, v_sigma)) *
      (1-pweibull(t,s_alpha, s_sigma))
   return(rc)
  }


#mean survival time for serologic and virologic. 
mns$sero.viro <- NA
for (i in 1:length(chains$lm)) {
  mns$sero.viro[i] <- 
    integrate(to.integrate, 0,Inf, 
              v_alpha= chains$v_alpha[i],
              v_sigma= chains$v_sigma[i],
              s_alpha= chains$s_alpha[i],
              s_sigma= chains$s_sigma[i])$value
  }

symptom.relative.sero <- quantile(mns$sero.viro/mns$viro,
                                  prob=c(0.025, .5, 0.975))


symptom.relative.inc
symptom.relative.sero


```


<!-- #Single interval censored survreg analysis. -->

<!-- Does a single interval censored analysis using survreg -->

```{r, eval=FALSE}
                   
#do incunation period first.
inc.low <- pmax(zika.anal$SL - zika.anal$ER, 0.01)
inc.high <-zika.anal$SR - zika.anal$EL
inc.surv <- Surv(inc.low, inc.high, event=rep(3, length(inc.high)),type="interval")

inc.sr <- survreg(inc.surv~1, dist="lognormal")
inc.sr
confint(inc.sr)


#do viral shedding
v.low <-  pmax(zika.anal$VCL - zika.anal$ER, 0.01)
v.high <-zika.anal$VCR - zika.anal$EL
v.surv <- Surv(v.low, v.high, type="interval2")
v.sr <- survreg(v.surv~1, dist="weibull", scale=1/vshed.fit.stan.LWW[1,1])
v.sr
confint(v.sr)

#do serology
s.low <-  pmax(zika.anal$ACL - zika.anal$ER, 0.01)
s.high <-zika.anal$ACR - zika.anal$EL
s.surv <- Surv(s.low, s.high, type="interval2")
s.sr <- survreg(s.surv~1, dist="weibull", scale =1/sero.fit.stan.LWW[1,1])
s.sr
confint(s.sr)

```


<!-- #Combined stan analysis Lognomal for incubation period, Gamma for others -->

```{r, eval=FALSE}
require(rstan)


#Create a dataset with everythign lined up for passing into STAN
zika.anal <- zika.inc[,c("UID","EL","ER","SL","SR")]
zika.anal <- merge(zika.anal, vshed.bl.anal, all=TRUE)
zika.anal$type <- 0 #we don't use this, but helps with the merge.
zika.anal <- merge(zika.anal, sero.anal, all=TRUE)

zika.anal$SL[which(is.na(zika.anal$SL))] <- 
  zika.anal$EL[which(is.na(zika.anal$SL))]
zika.anal$SR[which(is.na(zika.anal$SR))] <- 
   zika.anal$ER[which(is.na(zika.anal$SR))] + 100

zika.anal$ACL[which(is.na(zika.anal$ACL))] <-
  zika.anal$EL[which(is.na(zika.anal$ACL))]
zika.anal$ACR[which(is.na(zika.anal$ACR))] <- 
  zika.anal$ER[which(is.na(zika.anal$ACR))] + 720

zika.anal$VCL[which(is.na(zika.anal$VCL))] <-
  zika.anal$EL[which(is.na(zika.anal$VCL))]
zika.anal$VCR[which(is.na(zika.anal$VCR))] <- 
  zika.anal$ER[which(is.na(zika.anal$VCR))] + 720


zika.anal$VCR[which(is.infinite(zika.anal$VCR))] <- 
  zika.anal$ER[which(is.infinite(zika.anal$VCR))] + 720

#renormalize everything so EL is 0
zika.anal[,c("EL","ER","SL","SR","VCL","VCR","ACL","ACR")] <-
  zika.anal[,c("EL","ER","SL","SR","VCL","VCR","ACL","ACR")] -zika.anal$EL  


#for STAN purposes, it is usefule if all of these variables index 
#from 0
stan.data <- list(N=nrow(zika.anal),
                  EL=zika.anal$EL,
                  ER=zika.anal$ER,
                  SL=zika.anal$SL,
                  SR=zika.anal$SR,
                  VL=zika.anal$VCL,
                  VR=zika.anal$VCR, 
                  AL=zika.anal$ACL,
                  AR=zika.anal$ACR)


#initialization version for the lognormal/weibull stan model


#use uniform from halfway trhough the exposure interval to ER.
#still fails occasionally, but MUCH less often. 
stan.init.LGG <- function() {
    rc <-list(E=runif(stan.data$N, (stan.data$EL+stan.data$ER)/2, stan.data$ER),
                lm= runif(1,log(2),log(10)),
                lsd = runif(1,.1,2),
                v_alpha = 5,#,runif(1,5,10),
                v_beta= .1,# runif(1,.5,2) 
                s_alpha = 5,#,runif(1,5,10),
                s_beta= .1# runif(1,.5,2) 
                )
    #print(rc) #DEBUG
    #curve(dweibull(x,rc$v_alpha, rc$v_sigma), from=0, to=50) #DEBUG
    return(rc)
    }



#Need at least 35,000 iterations to converge
full.fit.LGG <- stan("DistributionFitLGG.stan", data=stan.data,
                  init=stan.init.LGG,
                  iter=100, chains=4, thin=1)

save(full.fit.LGG, file = "../FullFit.LGG.RData")

```


<!-- #Combined stan analysis Lognomal for incubation period, Gamma others -->
<!-- #THIS DOES NOT WORK!!!! -->
<!-- This is not working at this point. -->
```{r, eval=FALSE}
require(rstan)


#Create a dataset with everythign lined up for passing into STAN
zika.anal <- zika.inc[,c("UID","EL","ER","SL","SR")]
zika.anal <- merge(zika.anal, vshed.bl.anal, all=TRUE)

zika.anal$SL[which(is.na(zika.anal$SL))] <- 
  zika.anal$EL[which(is.na(zika.anal$SL))]
zika.anal$SR[which(is.na(zika.anal$SR))] <- 
   zika.anal$ER[which(is.na(zika.anal$SR))] + 100

zika.anal$VCL[which(is.na(zika.anal$VCL))] <-
  zika.anal$EL[which(is.na(zika.anal$VCL))]
zika.anal$VCR[which(is.na(zika.anal$VCR))] <- 
  zika.anal$ER[which(is.na(zika.anal$VCR))] + 720

zika.anal$VCR[which(is.infinite(zika.anal$VCR))] <- 
  zika.anal$ER[which(is.infinite(zika.anal$VCR))] + 720

#renormalize everything so EL is 0
zika.anal[,c("EL","ER","SL","SR","VCL","VCR")] <-
  zika.anal[,c("EL","ER","SL","SR","VCL","VCR")] -zika.anal$EL  


#for STAN purposes, it is usefule if all of these variables index 
#from 0
stan.data <- list(N=nrow(zika.anal),
                  EL=zika.anal$EL,
                  ER=zika.anal$ER,
                  SL=zika.anal$SL,
                  SR=zika.anal$SR,
                  VL=zika.anal$VCL,
                  VR=zika.anal$VCR)


#initialization version for the lognormal/gamma stan model
#in stan alpha = shape in R and beta = rate in R

#use uniform from halfway trhough the exposure interval to ER.
#still fails occasionally, but MUCH less often. 
stan.init.LG <- function() {
    rc <-list(E=runif(stan.data$N, (stan.data$EL+stan.data$ER)/2, stan.data$ER),
                lm= runif(1,log(2),log(10)),
                lsd = runif(1,.1,2),
                v_alpha = 5,#runif(1,5,10),
                v_beta= .1#runif(1,.1,1) 
                )
    #print(rc) #DEBUG
    
    return(rc)
    }



#Need at least 20,000 iterations to converge
full.fit <- stan("DistributionFitLG.stan", data=stan.data,
                  init=stan.init.LG,
                  iter=100, chains=4)


#now we need to calculate the quantiles from the chains and construct our
#data frame
chains <- extract(full.fit)


inc.fit.stan <- c(mean(chains$lm), quantile(chains$lm,prob=c(0.025,0.975)))
inc.fit.stan <- rbind(inc.fit.stan,
        c(mean(chains$lsd), quantile(chains$lsd,prob=c(0.025,0.975))))
for (q in c(0.05, 0.25, 0.5, 0.75, 0.95)) {
  tmp <- qlnorm(q, chains$lm, chains$lsd)
  inc.fit.stan <- rbind(inc.fit.stan,
                        c(mean(tmp), quantile(tmp, prob=c(0.025, 0.975))))
}

colnames(inc.fit.stan) <- c("est","CIlow","CIhigh")
rownames(inc.fit.stan) <- c("meanlog",
                            "sdlog",
                            "p5","p25","p50","p75","p95")



#in stan alpha = shape in R and beta = rate in R
vshed.fit.stan <- c(mean(chains$v_alpha), 
                    quantile(chains$v_alpha,prob=c(0.025,0.975)))
vshed.fit.stan <- rbind(vshed.fit.stan,
        c(mean(chains$v_beta), 
          quantile(chains$v_beta,prob=c(0.025,0.975))))
for (q in c(0.05, 0.25, 0.5, 0.75, 0.95)) {
  tmp <- qgamma(q, shape=chains$v_alpha, rate=chains$v_beta)
  vshed.fit.stan <- rbind(vshed.fit.stan,
                        c(mean(tmp), quantile(tmp, prob=c(0.025, 0.975))))
}

colnames(vshed.fit.stan) <- c("est","CIlow","CIhigh")
rownames(vshed.fit.stan) <- c("alpha (shape)",
                            "beta (rate)",
                            "p5","p25","p50","p75","p95")


```




<!-- #Appendix -->

<!-- ##Fitting just incubation period and time to seroconversion with Lognormal and gamma -->

```{r, eval=FALSE}
require(rstan)


#Create a dataset with everythign lined up for passing into STAN
zika.anal <- zika.inc[,c("UID","EL","ER","SL","SR")]
zika.anal <- merge(zika.anal, vshed.bl.anal, all=TRUE)

zika.anal$SL[which(is.na(zika.anal$SL))] <- 
  zika.anal$EL[which(is.na(zika.anal$SL))]
zika.anal$SR[which(is.na(zika.anal$SR))] <- 
   zika.anal$ER[which(is.na(zika.anal$SR))] + 100

zika.anal$VCL[which(is.na(zika.anal$VCL))] <-
  zika.anal$EL[which(is.na(zika.anal$VCL))]
zika.anal$VCR[which(is.na(zika.anal$VCR))] <- 
  zika.anal$ER[which(is.na(zika.anal$VCR))] + 720

zika.anal$VCR[which(is.infinite(zika.anal$VCR))] <- 
  zika.anal$ER[which(is.infinite(zika.anal$VCR))] + 720

#renormalize everything so EL is 0
zika.anal[,c("EL","ER","SL","SR","VCL","VCR")] <-
  zika.anal[,c("EL","ER","SL","SR","VCL","VCR")] -zika.anal$EL  


#for STAN purposes, it is usefule if all of these variables index 
#from 0
stan.data <- list(N=nrow(zika.anal),
                  EL=zika.anal$EL,
                  ER=zika.anal$ER,
                  SL=zika.anal$SL,
                  SR=zika.anal$SR,
                  VL=zika.anal$VCL,
                  VR=zika.anal$VCR)


#initialization version for the lognormal/weibull stan model


#use uniform from halfway trhough the exposure interval to ER.
#still fails occasionally, but MUCH less often. 
stan.init.LW <- function() {
    rc <-list(E=runif(stan.data$N, (stan.data$EL+stan.data$ER)/2, stan.data$ER),
                lm= runif(1,log(2),log(10)),
                lsd = runif(1,.1,2),
                v_alpha = 2,#,runif(1,5,10),
                v_sigma= 50# runif(1,.5,2) 
                )
    print(rc) #DEBUG
    curve(dweibull(x,rc$v_alpha, rc$v_sigma), from=0, to=50)
    return(rc)
    }



#Need at least 20,000 iterations to converge
full.fit.LW <- stan("DistributionFitLW.stan", data=stan.data,
                  init=stan.init.LW,
                  iter=35000, chains=4, thin=10)


#now we need to calculate the quantiles from the chains and construct our
#data frame
chains <- extract(full.fit)


inc.fit.stan.LW <- c(mean(chains$lm), quantile(chains$lm,prob=c(0.025,0.975)))
inc.fit.stan.LW <- rbind(inc.fit.stan.LW,
        c(mean(chains$lsd), quantile(chains$lsd,prob=c(0.025,0.975))))
for (q in c(0.05, 0.25, 0.5, 0.75, 0.95)) {
  tmp <- qlnorm(q, chains$lm, chains$lsd)
  inc.fit.stan.LW <- rbind(inc.fit.stan.LW,
                        c(mean(tmp), quantile(tmp, prob=c(0.025, 0.975))))
}

colnames(inc.fit.stan.LW) <- c("est","CIlow","CIhigh")
rownames(inc.fit.stan.LW) <- c("meanlog",
                            "sdlog",
                            "p5","p25","p50","p75","p95")



#in stan alpha = shape in R and beta = rate in R
vshed.fit.stan.LW <- c(mean(chains$v_alpha), 
                    quantile(chains$v_alpha,prob=c(0.025,0.975)))
vshed.fit.stan.LW <- rbind(vshed.fit.stan.LW,
        c(mean(chains$v_sigma), 
          quantile(chains$v_sigma,prob=c(0.025,0.975))))
for (q in c(0.05, 0.25, 0.5, 0.75, 0.95, 0.99)) {
  tmp <- qweibull(q, chains$v_alpha, chains$v_sigma)
  vshed.fit.stan.LW <- rbind(vshed.fit.stan.LW,
                        c(mean(tmp), quantile(tmp, prob=c(0.025, 0.975))))
}

colnames(vshed.fit.stan.LW) <- c("est","CIlow","CIhigh")
rownames(vshed.fit.stan.LW) <- c("alpha (shape)",
                            "sigma (scale)",
                            "p5","p25","p50","p75","p95","p99")


```


<!-- ## Some leftover plot code -->
```{r, eval=FALSE}

##########CODE FOR MAKING AN UGLY COMBINED PLOT########
#Try to use ggplot to plot a beautiful display of the data. 

#first make data frames to hold everything
inc.curve <- NULL
vc.curve <- NULL
sero.curve<- NULL

for (q in seq(0,30,.1)) {
    tmp <- plnorm(q, chains$lm, chains$lsd)
    tmp <- quantile(tmp, prob=c(0.025, .5, 0.975))
    inc.curve <- rbind(inc.curve, c(q=q,
                                    plow=tmp[1],
                                    pmid=tmp[2],
                                    phigh=tmp[3]))
    
    tmp <- 1-pweibull(q, chains$v_alpha, chains$v_sigma)
    tmp <- quantile(tmp, prob=c(0.025, .5, 0.975))
    vc.curve <- rbind(vc.curve, c(q=q,
                                  plow=tmp[1],
                                  pmid=tmp[2],
                                  phigh=tmp[3]))
    
    tmp <- pweibull(q, chains$s_alpha, chains$s_sigma)
    tmp <- quantile(tmp, prob=c(0.025, .5, 0.975))
    sero.curve <- rbind(sero.curve, c(q=q,
                                  plow=tmp[1],
                                  pmid=tmp[2],
                                  phigh=tmp[3]))
}
inc.curve <- as.data.frame(inc.curve)
colnames(inc.curve) <- c("q","incplow","incpmid","incphigh")

vc.curve <- as.data.frame(vc.curve)
colnames(vc.curve) <- c("q","vcplow","vcpmid","vcphigh")

sero.curve <- as.data.frame(sero.curve)
colnames(sero.curve) <- c("q","scplow","scpmid","scphigh")


require(ggplot2)


comb.curve<-merge(merge(inc.curve, vc.curve), sero.curve)
comb.plt <- ggplot(comb.curve, aes(x=q)) +
  geom_ribbon(aes(ymin=incplow, ymax=incphigh), fill="blue", alpha=.2) +
  geom_line(aes(y=incpmid), col="blue") +
  geom_ribbon(aes(ymin=vcplow, ymax=vcphigh), fill="red", alpha=.2) +
  geom_line(aes(y=vcpmid), col="red") +
  geom_ribbon(aes(ymin=scplow, ymax=scphigh), fill="green", alpha=.2) +
  geom_line(aes(y=scpmid), col="green") + xlim(0,25)

comb.plt

```


<!-- ##Combined stan analysis Lognormal for all distributions -->
```{r, eval=FALSE}
library(rstan)


#Create a dataset with everythign lined up for passing into STAN
zika.anal <- zika.inc[,c("UID","EL","ER","SL","SR")]
zika.anal <- merge(zika.anal, vshed.bl.anal, all=TRUE)

zika.anal$SL[which(is.na(zika.anal$SL))] <- 
  zika.anal$EL[which(is.na(zika.anal$SL))]
zika.anal$SR[which(is.na(zika.anal$SR))] <- 
   zika.anal$ER[which(is.na(zika.anal$SR))] + 100

zika.anal$VCL[which(is.na(zika.anal$VCL))] <-
  zika.anal$EL[which(is.na(zika.anal$VCL))]
zika.anal$VCR[which(is.na(zika.anal$VCR))] <- 
  zika.anal$ER[which(is.na(zika.anal$VCR))] + 720

zika.anal$VCR[which(is.infinite(zika.anal$VCR))] <- 
  zika.anal$ER[which(is.infinite(zika.anal$VCR))] + 720

#Replace

#for STAN purposes, it is usefule if all of these variables index 
#from 0
stan.data <- list(N=nrow(zika.anal),
                  EL=zika.anal$EL,
                  ER=zika.anal$ER,
                  SL=zika.anal$SL,
                  SR=zika.anal$SR,
                  VL=zika.anal$VCL,
                  VR=zika.anal$VCR)


#initialization version for the lognormal/lognormal stan model
stan.init.LL <- function() {
    rc <-list(E=runif(stan.data$N, stan.data$EL, stan.data$ER),
                lm=runif(1,log(2),log(10)),
                lsd = runif(1,.1,2),
                v_lm = runif(1,log(2),log(10)),
                v_lsd = runif(1,.1,2) 
                )
    print(rc)
    return(rc)
    }



#Need at least 20,000 iterations to converge
full.fit.LL <- stan("DistributionFitLL.stan", data=stan.data,
                  init=stan.init.LL,
                  iter=35000, chains=4, thin=10)


#now we need to calculate the quantiles from the chains and construct our
#data frame
chains <- extract(full.fit.LL)


inc.fit.stanLL <- c(mean(chains$lm), quantile(chains$lm,prob=c(0.025,0.975)))
inc.fit.stanLL <- rbind(inc.fit.stanLL,
        c(mean(chains$lsd), quantile(chains$lsd,prob=c(0.025,0.975))))
for (q in c(0.05, 0.25, 0.5, 0.75, 0.95)) {
  tmp <- qlnorm(q, chains$lm, chains$lsd)
  inc.fit.stanLL <- rbind(inc.fit.stanLL,
                        c(mean(tmp), quantile(tmp, prob=c(0.025, 0.975))))
}

colnames(inc.fit.stanLL) <- c("est","CIlow","CIhigh")
rownames(inc.fit.stanLL) <- c("meanlog",
                            "sdlog",
                            "p5","p25","p50","p75","p95")



vshed.fit.stanLL <- c(mean(chains$v_lm), quantile(chains$v_lm,prob=c(0.025,0.975)))
vshed.fit.stanLL <- rbind(vshed.fit.stanLL,
        c(mean(chains$v_lsd), quantile(chains$v_lsd,prob=c(0.025,0.975))))
for (q in c(0.05, 0.25, 0.5, 0.75, 0.95)) {
  tmp <- qlnorm(q, chains$v_lm, chains$v_lsd)
  vshed.fit.stanLL <- rbind(vshed.fit.stanLL,
                        c(mean(tmp), quantile(tmp, prob=c(0.025, 0.975))))
}

colnames(vshed.fit.stanLL) <- c("est","CIlow","CIhigh")
rownames(vshed.fit.stanLL) <- c("meanlog",
                            "sdlog",
                            "p5","p25","p50","p75","p95")


```


